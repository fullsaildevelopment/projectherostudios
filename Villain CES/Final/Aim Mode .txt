XMMATRIX CInputSystem::CharacterMovement(XMMATRIX d3dplayerMatrix, double delta, CAudioSystem* in_Audio, TClayton &clayton, XMVECTOR &playerVeclocity, bool move)
{

	XMMATRIX d3dTmpViewM, d3dMovementM, d3dRotation;
	XMVECTOR d3d_newX, d3d_newY, d3d_existingZ;
	d3dTmpViewM = d3dplayerMatrix;
	bool keyPressed = false;
	if (move == false)
	{
	
	 if (fXchange > 0.3f || fXchange < -0.3f)
	{
		d3dRotation = XMMatrixRotationY(fXchange * m_fMouseRotationSpeed * delta);
		
		d3dTmpViewM = XMMatrixMultiply(d3dRotation, d3dTmpViewM);
		d3d_existingZ = d3dTmpViewM.r[2];
		d3d_newX = XMVector3Cross(XMVectorSet(0, 1, 0, 0), d3d_existingZ);
		d3d_newY = XMVector3Cross(d3d_existingZ, d3d_newX);

		d3d_newX = XMVector3Normalize(d3d_newX);
		d3d_newY = XMVector3Normalize(d3d_newY);
		d3d_existingZ = XMVector3Normalize(d3d_existingZ);

		d3dTmpViewM.r[0] = d3d_newX;
		d3dTmpViewM.r[1] = d3d_newY;
		d3dTmpViewM.r[2] = d3d_existingZ;
	}
		

		//Forward && Back Movement
		// up key movement
		if (InputCheck(G_KEY_W) == 1) {
		d3dMovementM = XMMatrixTranslation(0, 0, m_fMouseMovementSpeed * delta);
		d3dTmpViewM = XMMatrixMultiply(d3dMovementM, d3dTmpViewM);
			stepCount++;
			keyPressed = true;
		}
			// down key movement
			if (InputCheck(G_KEY_S) == 1) {
			d3dMovementM = XMMatrixTranslation(0, 0, -m_fMouseMovementSpeed * delta);

		d3dTmpViewM = XMMatrixMultiply(d3dMovementM, d3dTmpViewM);
		keyPressed = true;
		stepCount++;
	}
	// left key movement
	if (InputCheck(G_KEY_A) == 1)
	{
		d3dMovementM = XMMatrixTranslation(-m_fMouseMovementSpeed * delta, 0, 0);
		d3dTmpViewM = XMMatrixMultiply(d3dMovementM, d3dTmpViewM);
		keyPressed = true;
		stepCount++;

	}
	// right key movement
	if (InputCheck(G_KEY_D) == 1) 
	{
		d3dMovementM = XMMatrixTranslation(m_fMouseMovementSpeed * delta, 0, 0);
		d3dTmpViewM = XMMatrixMultiply(d3dMovementM, d3dTmpViewM);
		keyPressed = true;
		stepCount++;
	}
	if (InputCheck(G_KEY_SPACE) == 1 && clayton.jumpTime > 0 && playerVeclocity.m128_f32[1] > -.1)
	{
		d3dMovementM = XMMatrixTranslation(0, m_fMouseMovementSpeed * delta, 0);
		d3dTmpViewM = XMMatrixMultiply(d3dMovementM, d3dTmpViewM);
		keyPressed = true;
		stepCount++;

		clayton.jumpTime -= delta;

		if (clayton.jumpTime <= 0)
		{
			clayton.jumpCooldown = 1;
		}
	}
	else if (InputCheck(G_KEY_SPACE) == 0 && clayton.jumpTime > 0)
	{
		if (clayton.jumpTime < 1)
		{
			clayton.jumpTime += delta;
		}
	}

			if (keyPressed == true && stepCount == 20)
			{
#if MUSIC_ON
		in_Audio->SendSoundsToEngine(AK::EVENTS::PLAY_WALK, in_Audio->m_WalkSound);
		stepCount = 0;
#endif
			}
			if (stepCount > 20)
			{
			stepCount = 0;
			}
		
	}
	
	return d3dTmpViewM;
}
XMMATRIX CInputSystem::AimMode(TCamera * in_AimCamera, XMMATRIX d3dplayerMatrix, double delta, bool move)
{
	XMMATRIX d3dTmpViewM, d3dMovementM, d3dRotation;
	GReturn input_Check;
	d3dTmpViewM = d3dplayerMatrix;

	XMVECTOR d3d_newX, d3d_newY, d3d_existingZ;
	 m_pcMyInput->GetMousePosition(fXEnd, fYEnd);

	//MouseBoundryCheck(fXEnd, fYEnd, fXchange, fYchange);
	//Display current mouse pose
	
	// Check thatacts like a deadzone and for getting a good mouse pos delta
	//if (fXEnd > 2.0f && fXEnd < 1410.0f && fYEnd > 2.0f && fYEnd < 700.0f)
	//{
	if (move == false)
	{

		if (InputCheck(G_KEY_K) == 1)
		{
			std::string stTimeDisplay;
			stTimeDisplay = "X Change: ";
			stTimeDisplay += std::to_string(fXchange);
			cout << stTimeDisplay << endl;

			stTimeDisplay = "Y Change: ";
			stTimeDisplay += std::to_string(fYchange);
			cout << stTimeDisplay << endl;
		}

		input_Check = m_pcMyInput->GetMouseDelta(fXchange, fYchange);
		if (prev_fXchange == fXchange && prev_fYchange == fYchange && (prev_fXchange != 0 || prev_fYchange != 0) && input_Check == REDUNDANT_OPERATION)
		{
			fXchange = 0;
			fYchange = 0;
			//in_AimCamera->fPitch = 0;
			
		}
		else if (fYchange > 0.3f || fYchange < -0.3f)
		{
			in_AimCamera->fPitch += fYchange;

			if (in_AimCamera->fPitch >= 90.0f)
			{
				in_AimCamera->fPitch = 89.0f;
			}
			else if (in_AimCamera->fPitch <= -90.0f)
			{
				in_AimCamera->fPitch = -89.0f;
			}
		}
		
		d3dRotation = XMMatrixRotationX(in_AimCamera->fPitch * m_fMouseRotationSpeed);
		d3dTmpViewM = XMMatrixMultiply(d3dTmpViewM, d3dRotation);

		//d3dTmpViewM = XMMatrixMultiply(d3dTmpViewM, d3dRotation);

		// see if you can lerp fxchange or end to get a lerped value
		d3dRotation = XMMatrixRotationY(fXchange * m_fMouseRotationSpeed * delta);
		d3dTmpViewM = XMMatrixMultiply(d3dRotation, d3dTmpViewM);
		//d3dTmpViewM = XMMatrixMultiply(d3dRotation, d3dTmpViewM); 
		//Debug 
		

		//Gimbal-Lock implementation
		d3d_existingZ = d3dTmpViewM.r[2];
		d3d_newX = XMVector3Cross(XMVectorSet(0, 1, 0, 0), d3d_existingZ);
		d3d_newY = XMVector3Cross(d3d_existingZ, d3d_newX);

		d3d_newX = XMVector3Normalize(d3d_newX);
		d3d_newY = XMVector3Normalize(d3d_newY);
		d3d_existingZ = XMVector3Normalize(d3d_existingZ);

		d3dTmpViewM.r[0] = d3d_newX;
		d3dTmpViewM.r[1] = d3d_newY;
		d3dTmpViewM.r[2] = d3d_existingZ;

		if (input_Check != REDUNDANT_OPERATION)
		{
		prev_fXchange = fXchange;
		prev_fYchange = fYchange;
		}
		
	}
		
	
		/*d3d_existingZ = d3dTmpViewM.r[2];
		d3d_newX = XMVector3Cross(XMVectorSet(0, 1, 0, 0), d3d_existingZ);
		d3d_newY = XMVector3Cross(d3d_existingZ, d3d_newX);

		d3d_newX = XMVector3Normalize(d3d_newX);
		d3d_newY = XMVector3Normalize(d3d_newY);

		d3d_existingZ = XMVector3Normalize(d3d_existingZ);

		d3dTmpViewM.r[0] = d3d_newX;
		d3dTmpViewM.r[1] = d3d_newY;
		d3dTmpViewM.r[2] = d3d_existingZ;*/

	//}
	
		return d3dTmpViewM;
}